package customchips

import (
	"fmt"
	"reflect"
	"wiless/gocomm"
	"wiless/gocomm/chipset"
	"wiless/gocomm/dsp"
)

func init() {
	fmt.Printf("\n OFDM Chip from customchips")
}

type OFDM struct {
	name          string
	isInitialized bool
	Pins          map[string]chipset.PinInfo
	Modules       map[string]chipset.ModuleInfo
	ModuleNames   map[int]string
	PinNames      map[int]string
	NPoint        int
	NCP           int
}

/// AutoGenerated through script

func (m OFDM) InPinCount() int {
	return 2
}

func (m OFDM) OutPinCount() int {
	return 2
}

func (m OFDM) Pin(pid int) chipset.PinInfo {
	return m.Pins[m.PinNames[pid]]
}

func (m OFDM) PinIn(pid int) chipset.PinInfo {
	if pid >= m.InPinCount() {
		fmt.Printf("%d > No of Input Pins %d", pid, m.InPinCount())
		var result chipset.PinInfo
		result.Id = -1
		return result
	}

	return m.Pins[m.PinNames[pid]]

}
func (m OFDM) PinByID(pid int) chipset.PinInfo {

	return m.Pins[m.PinNames[pid]]
}

func (m OFDM) PinOut(pid int) chipset.PinInfo {
	if pid >= m.OutPinCount() {
		fmt.Printf("%d > No of Output Pins %d", pid, m.OutPinCount())
		var result chipset.PinInfo
		result.Id = -1
		return result
	}
	return m.Pins[m.PinNames[pid+m.InPinCount()]]

}

func (m OFDM) PinByName(pinname string) chipset.PinInfo {
	return m.Pins[pinname]
}

func (m OFDM) ModulesCount() int {
	return 2
}
func (m OFDM) ModuleByName(mname string) chipset.ModuleInfo {
	return m.Modules[mname]
}

func (m OFDM) Module(moduleid int) chipset.ModuleInfo {
	return m.ModuleByName(m.ModuleNames[moduleid])
}

func (m OFDM) SayHello() {
	fmt.Printf("\n Hi from \n %v", m.Name())
}

func (m OFDM) Name() string {
	return "OFDM"
}

func (m OFDM) IsInitialized() bool {
	return m.isInitialized
}

func (m *OFDM) InitializeChip() {
	m.name = "OFDM"
	m.InitPins()
	m.InitModules()
}

func (m *OFDM) InitPins() {
	totalpins := m.InPinCount() + m.OutPinCount()
	m.Pins = make(map[string]chipset.PinInfo, totalpins)
	m.PinNames = make(map[int]string, totalpins)
	strlist := [4]string{"inputPin0", "inputPin1", "outputPin0", "outputPin1"}
	for cnt := 0; cnt < len(strlist); cnt++ {
		m.PinNames[cnt] = strlist[cnt]
	}

	/// something try begins
	var pinfo chipset.PinInfo

	pinfo.Name = "inputPin0"
	pinfo.Id = 0
	pinfo.InputPin = true

	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128AChannel)(nil)).Elem()

	m.Pins["inputPin0"] = pinfo

	pinfo.Name = "inputPin1"
	pinfo.Id = 1
	pinfo.InputPin = true
	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128AChannel)(nil)).Elem()

	m.Pins["inputPin1"] = pinfo

	pinfo.Name = "outputPin0"
	pinfo.Id = 2
	pinfo.InputPin = false
	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128AChannel)(nil)).Elem()

	pinfo.CreateChannel()

	m.Pins["outputPin0"] = pinfo

	pinfo.Name = "outputPin1"
	pinfo.Id = 3
	pinfo.InputPin = false
	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128AChannel)(nil)).Elem()

	pinfo.CreateChannel()

	m.Pins["outputPin1"] = pinfo

	/// something try ends

}

func (m *OFDM) InitModules() {

	var totalModules int = 2

	/// AUTO CODE
	/// something try begins
	var minfo chipset.ModuleInfo
	m.Modules = make(map[string]chipset.ModuleInfo, totalModules)
	m.ModuleNames = make(map[int]string, totalModules)

	strlist := [2]string{"txmodule", "rxmodule"}
	for cnt := 0; cnt < len(strlist); cnt++ {
		m.ModuleNames[cnt] = strlist[cnt]
	}
	var temp, otemp []int

	minfo.Name = "txmodule"
	minfo.Id = 0
	minfo.Desc = ""

	temp = append(temp, m.PinByName("inputPin0").Id)

	otemp = append(otemp, m.PinByName("outputPin0").Id)

	minfo.InPins = temp
	minfo.OutPins = otemp
	method := reflect.ValueOf(m).MethodByName("Ifft")
	minfo.Function = method
	minfo.FunctionName = "Ifft"

	m.Modules["txmodule"] = minfo

	minfo.Name = "rxmodule"
	minfo.Id = 1
	minfo.Desc = ""

	temp = append(temp, m.PinByName("inputPin1").Id)

	otemp = append(otemp, m.PinByName("outputPin1").Id)

	minfo.InPins = temp
	minfo.OutPins = otemp
	method = reflect.ValueOf(m).MethodByName("Fft")
	minfo.Function = method
	minfo.FunctionName = "Fft"
	m.Modules["rxmodule"] = minfo

	/// AUTO CODE

	m.isInitialized = true
}

func (m *OFDM) Ifft(inputPin0 gocomm.Complex128AChannel) {
	/// Read your data from Input channel(s) [inputPin0]
	/// And write it to OutputChannels  [outputPin0]

	outputPin0 := m.Pins["outputPin0"].Channel.(gocomm.Complex128AChannel)
	iters := 1
	for i := 0; i < iters; i++ {
		chData := <-inputPin0
		iters = chData.MaxExpected
		fsamples := chData.Ch
		/// Do process here with chData

		var outData gocomm.SComplex128AObj
		outData.Ch = dsp.ExtIFFT_C(fsamples, m.NPoint)
		/// copy meta
		outData.MaxExpected = chData.MaxExpected
		outData.Ts = chData.Ts
		outData.TimeStamp = chData.TimeStamp
		outData.Message = chData.Message

		outputPin0 <- outData
	}

}

func (m *OFDM) Fft(inputPin1 gocomm.Complex128AChannel) {
	/// Read your data from Input channel(s) [inputPin1]
	/// And write it to OutputChannels  [outputPin1]

	outputPin1 := m.Pins["outputPin1"].Channel.(gocomm.Complex128AChannel)
	iters := 1
	for i := 0; i < iters; i++ {
		chData := <-inputPin1
		iters = chData.MaxExpected
		tsamples := chData.Ch
		/// Do process here with chData

		var outData gocomm.SComplex128AObj
		outData.Ch = dsp.ExtFFT_C(tsamples, m.NPoint)

		/// copy meta
		outData.MaxExpected = chData.MaxExpected
		outData.Ts = chData.Ts
		outData.TimeStamp = chData.TimeStamp
		outData.Message = chData.Message

		outputPin1 <- outData
		iters = chData.MaxExpected
	}

}
