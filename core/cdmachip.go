package core

import (
	"fmt"
	"reflect"
	"wiless/gocomm"
	"wiless/gocomm/chipset"
	"wiless/vlib"
)

func init() {
	fmt.Printf("\n AutoGenerated package customchips")
}

type CDMA struct {
	name          string
	isInitialized bool
	Pins          map[string]chipset.PinInfo
	Modules       map[string]chipset.ModuleInfo
	ModuleNames   map[int]string
	PinNames      map[int]string

	/// Meta Data
	spreadSeq vlib.VectorC
	sf        int
}

/// AutoGenerated through script

func (m CDMA) InPinCount() int {
	return 2
}

func (m CDMA) OutPinCount() int {
	return 2
}

func (m CDMA) Pin(pid int) chipset.PinInfo {
	return m.Pins[m.PinNames[pid]]
}

func (m CDMA) PinIn(pid int) chipset.PinInfo {
	if pid >= m.InPinCount() {
		fmt.Printf("%d > No of Input Pins %d", pid, m.InPinCount())
		var result chipset.PinInfo
		result.Id = -1
		return result
	}

	return m.Pins[m.PinNames[pid]]

}
func (m CDMA) PinByID(pid int) chipset.PinInfo {

	return m.Pins[m.PinNames[pid]]
}

func (m CDMA) PinOut(pid int) chipset.PinInfo {
	if pid >= m.OutPinCount() {
		fmt.Printf("%d > No of Output Pins %d", pid, m.OutPinCount())
		var result chipset.PinInfo
		result.Id = -1
		return result
	}
	return m.Pins[m.PinNames[pid+m.InPinCount()]]

}

func (m CDMA) PinByName(pinname string) chipset.PinInfo {
	return m.Pins[pinname]
}

func (m CDMA) ModulesCount() int {
	return 2
}
func (m CDMA) ModuleByName(mname string) chipset.ModuleInfo {
	return m.Modules[mname]
}

func (m CDMA) Module(moduleid int) chipset.ModuleInfo {
	return m.ModuleByName(m.ModuleNames[moduleid])
}

func (m CDMA) SayHello() {
	fmt.Printf("\n Hi from \n %v", m.Name())
}

func (m CDMA) Name() string {
	return "CDMA"
}

func (m CDMA) IsInitialized() bool {
	return m.isInitialized
}

func (m *CDMA) InitializeChip() {
	m.name = "CDMA"
	m.InitPins()
	m.InitModules()
}

func (m *CDMA) GetSpreadCode() (spcode vlib.VectorC) {
	return m.spreadSeq
}
func (m *CDMA) SetSpreadCode(spcode vlib.VectorC, doscale bool) {
	m.sf = spcode.Size()
	// normalize := 1.0 / float64(m.sf)
	if doscale {
		m.spreadSeq, _ = spcode.ToUnitEnergy() //spcode.Scale(normalize)
	} else {
		m.spreadSeq = spcode //;.ToUnitEnergy() //spcode.Scale(normalize)
	}

	// fmt.Print("\ndata", m.spreadSeq, temp, a)

}

func (c *CDMA) GetSF() int {
	return c.spreadSeq.Size()
}

func (m *CDMA) InitPins() {
	totalpins := m.InPinCount() + m.OutPinCount()
	m.Pins = make(map[string]chipset.PinInfo, totalpins)
	m.PinNames = make(map[int]string, totalpins)
	strlist := [4]string{"inputSymbols", "inputChipsSamples", "outputChips", "outputSymbol"}
	for cnt := 0; cnt < len(strlist); cnt++ {
		m.PinNames[cnt] = strlist[cnt]
	}

	/// something try begins
	var pinfo chipset.PinInfo

	pinfo.Name = "inputSymbols"
	pinfo.Id = 0
	pinfo.InputPin = true
	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128Channel)(nil)).Elem()

	m.Pins["inputSymbols"] = pinfo

	pinfo.Name = "inputChipsSamples"
	pinfo.Id = 1
	pinfo.InputPin = true
	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128Channel)(nil)).Elem()

	m.Pins["inputChipsSamples"] = pinfo

	pinfo.Name = "outputChips"
	pinfo.Id = 2
	pinfo.InputPin = false
	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128AChannel)(nil)).Elem()

	pinfo.CreateChannel()

	m.Pins["outputChips"] = pinfo

	pinfo.Name = "outputSymbol"
	pinfo.Id = 3
	pinfo.InputPin = false
	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128Channel)(nil)).Elem()

	pinfo.CreateChannel()

	m.Pins["outputSymbol"] = pinfo

	/// something try ends

}

func (m *CDMA) InitModules() {

	var totalModules int = 2

	/// AUTO CODE
	/// something try begins
	var minfo chipset.ModuleInfo
	m.Modules = make(map[string]chipset.ModuleInfo, totalModules)
	m.ModuleNames = make(map[int]string, totalModules)

	strlist := [2]string{"Spread", "DeSpread"}
	for cnt := 0; cnt < len(strlist); cnt++ {
		m.ModuleNames[cnt] = strlist[cnt]
	}
	var temp, otemp []int

	minfo.Name = "Spread"
	minfo.Id = 0
	minfo.Desc = ""

	temp = append(temp, m.PinByName("inputSymbols").Id)

	otemp = append(otemp, m.PinByName("outputChips").Id)

	minfo.InPins = temp
	minfo.OutPins = otemp
	m.Modules["Spread"] = minfo

	minfo.Name = "DeSpread"
	minfo.Id = 1
	minfo.Desc = ""

	temp = append(temp, m.PinByName("inputChipsSamples").Id)

	otemp = append(otemp, m.PinByName("outputSymbol").Id)

	minfo.InPins = temp
	minfo.OutPins = otemp
	m.Modules["DeSpread"] = minfo

	/// AUTO CODE

	m.isInitialized = true
}

func (m *CDMA) SpreadFn(inputSymbols gocomm.SComplex128Obj) (chipvector gocomm.SComplex128AObj) {

	chipvector.Ch = m.spreadSeq.ScaleC(inputSymbols.Ch)
	chipvector.MaxExpected = inputSymbols.MaxExpected
	chipvector.Ts = inputSymbols.Ts
	chipvector.Message = inputSymbols.Message + " Spread"
	chipvector.TimeStamp = inputSymbols.TimeStamp

	// chipvector.Next(m.spreadSeq.ScaleC(inputSymbols.Ch))
	return chipvector
}

func (m *CDMA) Spread(inputSymbols gocomm.Complex128Channel) {
	/// Read your data from Input channel(s) [inputSymbols]
	/// And write it to OutputChannels  [outputChips]

	outputChips := m.Pins["outputChips"].Channel.(gocomm.Complex128AChannel)
	iters := 1
	for i := 0; i < iters; i++ {
		chData := <-inputSymbols
		iters = chData.MaxExpected
		/// Do process here with chData
		outData := m.SpreadFn(chData)
		outputChips <- outData

	}

}
func (m *CDMA) DeSpreadFn(inputChipsSamples gocomm.SComplex128AObj) (outputSample gocomm.SComplex128Obj) {

	outputSample.Ch = vlib.DotC(inputChipsSamples.Ch, m.spreadSeq)
	// fmt.Printf("Dummping output %v", outputSample.Ch)
	outputSample.MaxExpected = inputChipsSamples.MaxExpected
	outputSample.Ts = inputChipsSamples.Ts
	outputSample.Message = inputChipsSamples.Message + " DESP"
	outputSample.TimeStamp = inputChipsSamples.TimeStamp

	return outputSample
}
func (m *CDMA) DeSpread(inputChipsSamples gocomm.Complex128Channel) {
	/// Read your data from Input channel(s) [inputChipsSamples]
	/// And write it to OutputChannels  [outputSymbol]

	outputSymbol := m.Pins["outputSymbol"].Channel.(gocomm.Complex128Channel)
	OutCH := gocomm.NewComplex128AChannel()
	go gocomm.Complex2ComplexA(inputChipsSamples, OutCH, m.GetSF())

	iters := 1
	for i := 0; i < iters; i++ {
		vecdata := <-OutCH
		iters = vecdata.MaxExpected
		/// Do process here with chData
		outData := m.DeSpreadFn(vecdata)
		outputSymbol <- outData

	}

}
