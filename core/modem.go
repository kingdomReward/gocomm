package core

import (
	"fmt"
	"log"
	"math/cmplx"
	"reflect"
	"wiless/gocomm"
	"wiless/gocomm/chipset"
	"wiless/gocomm/modem"
	"wiless/vlib"
)

func init() {
	log.Println("core::Modem")
}

type Modem struct {
	modem.Modem
	name          string
	isInitialized bool
	Pins          map[string]chipset.PinInfo
	Modules       map[string]chipset.ModuleInfo
	ModuleNames   map[int]string
	PinNames      map[int]string
	recentCoeff   gocomm.SComplex128AObj
	feedbackCH    gocomm.Complex128AChannel
}

func (m *Modem) SetFeedbackChannel(feedback gocomm.Complex128AChannel) {
	m.feedbackCH = feedback
	m.recentCoeff.Ts = -1
	m.recentCoeff.TimeStamp = -1

}

func (m *Modem) InitModem(bitwidth int) {
	m.Modem.Init(bitwidth, "QPSK")
}

/// AutoGenerated through script

func (m Modem) InPinCount() int {
	return 2
}

func (m Modem) OutPinCount() int {
	return 2
}

func (m Modem) Pin(pid int) chipset.PinInfo {
	return m.Pins[m.PinNames[pid]]
}

func (m *Modem) SetName(nameit string) {
	m.name = nameit
	//fmt.Print(m.Name())
}

func (m Modem) PinIn(pid int) chipset.PinInfo {
	if pid >= m.InPinCount() {
		fmt.Printf("%d > No of Input Pins %d", pid, m.InPinCount())
		var result chipset.PinInfo
		result.Id = -1
		return result
	}

	return m.Pins[m.PinNames[pid]]

}
func (m Modem) PinByID(pid int) chipset.PinInfo {

	return m.Pins[m.PinNames[pid]]
}

func (m Modem) PinOut(pid int) chipset.PinInfo {
	if pid >= m.OutPinCount() {
		fmt.Printf("%d > No of Output Pins %d", pid, m.OutPinCount())
		var result chipset.PinInfo
		result.Id = -1
		return result
	}
	return m.Pins[m.PinNames[pid+m.InPinCount()]]

}

func (m Modem) PinByName(pinname string) chipset.PinInfo {
	return m.Pins[pinname]
}

func (m Modem) ModulesCount() int {
	return 2
}
func (m Modem) ModuleByName(mname string) chipset.ModuleInfo {
	return m.Modules[mname]
}

func (m Modem) Module(moduleid int) chipset.ModuleInfo {
	return m.ModuleByName(m.ModuleNames[moduleid])
}

func (m Modem) SayHello() {
	fmt.Printf("\n Hi from \n %v", m.Name())
}

func (m Modem) Name() string {
	return m.name
}

func (m Modem) IsInitialized() bool {
	return m.isInitialized
}

func (m *Modem) InitializeChip() {
	m.name = "Modem"
	m.InitPins()
	m.InitModules()
}

func (m *Modem) InitPins() {

	totalpins := m.InPinCount() + m.OutPinCount()
	m.Pins = make(map[string]chipset.PinInfo, totalpins)
	m.PinNames = make(map[int]string, totalpins)
	strlist := [5]string{"inputPin0", "inputPin1", "outputPin0", "outputPin1", "coeffPin"}
	for cnt := 0; cnt < len(strlist); cnt++ {
		m.PinNames[cnt] = strlist[cnt]
	}

	/// something try begins
	var pinfo chipset.PinInfo

	pinfo.Name = "inputPin0"
	pinfo.Id = 0
	pinfo.InputPin = true
	pinfo.DataType = reflect.TypeOf((*gocomm.BitChannel)(nil)).Elem()

	m.Pins["inputPin0"] = pinfo

	pinfo.Name = "inputPin1"
	pinfo.Id = 1
	pinfo.InputPin = true
	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128Channel)(nil)).Elem()

	m.Pins["inputPin1"] = pinfo

	pinfo.Name = "outputPin0"
	pinfo.Id = 2
	pinfo.InputPin = false
	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128Channel)(nil)).Elem()

	pinfo.CreateChannel()

	m.Pins["outputPin0"] = pinfo

	pinfo.Name = "outputPin1"
	pinfo.Id = 3
	pinfo.InputPin = false
	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128Channel)(nil)).Elem()

	pinfo.CreateChannel()

	m.Pins["outputPin1"] = pinfo

	pinfo.Name = "coeffPin"
	pinfo.Id = 4
	pinfo.InputPin = true
	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128AChannel)(nil)).Elem()

	pinfo.CreateChannel()

	m.Pins["coeffPin"] = pinfo

	/// something try ends

}

func (m *Modem) InitModules() {

	var totalModules int = 3

	/// AUTO CODE
	/// something try begins
	var minfo chipset.ModuleInfo
	m.Modules = make(map[string]chipset.ModuleInfo, totalModules)
	m.ModuleNames = make(map[int]string, totalModules)

	strlist := [3]string{"modulate", "demodulate", "updateCoeff"}
	for cnt := 0; cnt < len(strlist); cnt++ {
		m.ModuleNames[cnt] = strlist[cnt]
	}
	var temp, otemp []int

	minfo.Name = "modulate"
	minfo.Id = 0
	minfo.Desc = ""

	temp = append(temp, m.PinByName("inputPin0").Id)
	otemp = append(otemp, m.PinByName("outputPin0").Id)

	minfo.InPins = temp
	minfo.OutPins = otemp
	m.Modules["modulate"] = minfo

	minfo.Name = "demodulate"
	minfo.Id = 1
	minfo.Desc = ""

	temp = append(temp, m.PinByName("inputPin1").Id)

	otemp = append(otemp, m.PinByName("outputPin1").Id)

	minfo.InPins = temp
	minfo.OutPins = otemp
	m.Modules["demodulate"] = minfo

	/// AUTO CODE

	m.isInitialized = true
}

func (m *Modem) Modulate(inputPin0 gocomm.BitChannel) {
	/// Read your data from Input channel(s) [inputPin0]
	/// And write it to OutputChannels  [outputPin0]

	OutCH := gocomm.NewBitAChannel()
	// fmt.Printf("\n NEW Modulate : %v", m.BitsPerSymbol())
	go gocomm.Bit2BitA(inputPin0, OutCH, m.BitsPerSymbol())

	outputPin0 := m.Pins["outputPin0"].Channel.(gocomm.Complex128Channel)
	iters := 1
	for i := 0; i < iters; i++ {
		chData := <-OutCH
		iters = chData.MaxExpected
		/// Do process here with chData
		outData := m.ModulateFn(chData)
		outputPin0 <- outData

	}

}

func (m *Modem) ModulateFn(bitAObj gocomm.SBitAObj) (cmplxObj gocomm.SComplex128Obj) {
	bits := vlib.VectorB(bitAObj.Ch)
	key := bits.ToString()
	cmplxObj.Ch = m.GetConstellationTable()[key]
	cmplxObj.MaxExpected = bitAObj.MaxExpected
	cmplxObj.Message = bitAObj.Message + " Mod"
	cmplxObj.TimeStamp = bitAObj.TimeStamp
	cmplxObj.Ts = bitAObj.Ts
	//fmt.Printf("\nMode output %v", cmplxObj.Ch)
	return cmplxObj
}

func (m *Modem) DeModulateFn(inObj gocomm.SComplex128Obj) (cmplxObj gocomm.SComplex128Obj) {

	symbol := inObj.Ch
	// fmt.Printf("\n Modem feedback channel %v", m.feedbackCH)
	// fmt.Printf("\nNow %#v Channel coeff from %#v ", inObj, m.recentCoeff)

	/// See if CSI is available
	if len(m.recentCoeff.Ch) != 0 {
		gain := cmplx.Abs(m.recentCoeff.Ch[0]) * cmplx.Abs(m.recentCoeff.Ch[0])
		eqcoeff := cmplx.Conj(m.recentCoeff.Ch[0]) / complex(gain, 0)
		// fmt.Printf("\n Now %v : Equalizing  Coeff:%v - Gain : %v  \n EQOUTPUT  : %v", inObj.TimeStamp, m.recentCoeff.Ch[0], gain, symbol*eqcoeff)
		symbol = symbol * eqcoeff
	}

	bits := m.DeModulateBits(symbol)
	result := complex(float64(bits[0]), float64(bits[1]))

	cmplxObj.Ch = result
	cmplxObj.MaxExpected = inObj.MaxExpected
	cmplxObj.Message = inObj.Message + " DeMod"
	cmplxObj.TimeStamp = inObj.TimeStamp
	cmplxObj.Ts = inObj.Ts
	// fmt.Printf("\n Demod I/O : %#v --> %#v", inObj, cmplxObj)
	return cmplxObj
}

func (m *Modem) updateCoeff(timestamp float64) {

	/// Check if feedback channel available
	if m.feedbackCH != nil {
		/// Was recently updated ??

		if m.recentCoeff.TimeStamp == -1 {
			// blindly update
			m.recentCoeff = <-m.feedbackCH
			// fmt.Printf("\nDEMOD Update needed : FIRST TIME , valid till %v", m.recentCoeff.TimeStamp+m.recentCoeff.Ts)

		} else {
			isValid := timestamp < (m.recentCoeff.TimeStamp + m.recentCoeff.Ts)
			if !isValid {
				// fmt.Printf("\nDEMOD Update needed : for %v, recent coeff was valid till %v only", timestamp, m.recentCoeff.TimeStamp+m.recentCoeff.Ts)
				m.recentCoeff = <-m.feedbackCH
				// fmt.Printf("\nDEMOD NEW COEFF valid till  %v only", m.recentCoeff.TimeStamp+m.recentCoeff.Ts)

			} else {

				// fmt.Printf("\nDEMOD Now %v Continue using old COEFF valid till  %v", timestamp, m.recentCoeff.TimeStamp+m.recentCoeff.Ts, m.recentCoeff)
			}

		}

	}

}

func (m *Modem) DeModulate(inputPin1 gocomm.Complex128Channel) {
	/// Read your data from Input channel(s) [inputPin1]
	/// And write it to OutputChannels  [outputPin1]
	///
	iters := 1
	outputPin1 := m.Pins["outputPin1"].Channel.(gocomm.Complex128Channel)
	for i := 0; i < iters; i++ {
		chData := <-inputPin1
		//fmt.Printf("\n Rx Demodulator symbol %#v", chData)
		iters = chData.MaxExpected
		/// Do process here with chData
		m.updateCoeff(chData.TimeStamp)
		outData := m.DeModulateFn(chData)
		outputPin1 <- outData
	}

}
