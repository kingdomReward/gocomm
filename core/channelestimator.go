package core

import (
	"fmt"
	"reflect"
	"wiless/gocomm"
	"wiless/gocomm/chipset"
	"wiless/vlib"
	"log"
)

func init() {
	log.Print("ChannelEstimator Init")
}

type MetaData struct {
	recentTime  float64
	recentCoeff vlib.VectorC
	Mode        string
	idealTs     float64
}

type ChannelEstimator struct {
	MetaData
	name          string
	isInitialized bool
	Pins          map[string]chipset.PinInfo
	Modules       map[string]chipset.ModuleInfo
	ModuleNames   map[int]string
	PinNames      map[int]string
}

/// AutoGenerated through script

func (m ChannelEstimator) InPinCount() int {
	return 2
}

func (m ChannelEstimator) OutPinCount() int {
	return 2
}

func (m ChannelEstimator) Pin(pid int) chipset.PinInfo {
	return m.Pins[m.PinNames[pid]]
}

func (m ChannelEstimator) PinIn(pid int) chipset.PinInfo {
	if pid >= m.InPinCount() {
		fmt.Printf("%d > No of Input Pins %d", pid, m.InPinCount())
		var result chipset.PinInfo
		result.Id = -1
		return result
	}

	return m.Pins[m.PinNames[pid]]

}
func (m ChannelEstimator) PinByID(pid int) chipset.PinInfo {

	return m.Pins[m.PinNames[pid]]
}

func (m ChannelEstimator) PinOut(pid int) chipset.PinInfo {
	if pid >= m.OutPinCount() {
		fmt.Printf("%d > No of Output Pins %d", pid, m.OutPinCount())
		var result chipset.PinInfo
		result.Id = -1
		return result
	}
	return m.Pins[m.PinNames[pid+m.InPinCount()]]

}

func (m ChannelEstimator) PinByName(pinname string) chipset.PinInfo {
	return m.Pins[pinname]
}

func (m ChannelEstimator) ModulesCount() int {
	return 2
}
func (m ChannelEstimator) ModuleByName(mname string) chipset.ModuleInfo {
	return m.Modules[mname]
}

func (m ChannelEstimator) Module(moduleid int) chipset.ModuleInfo {
	return m.ModuleByName(m.ModuleNames[moduleid])
}

func (m ChannelEstimator) SayHello() {
	fmt.Printf("\n Hi from \n %v", m.Name())
}

func (m ChannelEstimator) Name() string {
	return "ChannelEstimator"
}

func (m ChannelEstimator) IsInitialized() bool {
	return m.isInitialized
}

func (m *ChannelEstimator) InitializeChip() {
	m.name = "ChannelEstimator"
	m.InitPins()
	m.InitModules()
}

func (m *ChannelEstimator) InitPins() {
	totalpins := m.InPinCount() + m.OutPinCount()
	m.Pins = make(map[string]chipset.PinInfo, totalpins)
	m.PinNames = make(map[int]string, totalpins)
	strlist := [4]string{"outputPin1", "inputPin0", "inputPin1", "outputPin0"}
	for cnt := 0; cnt < len(strlist); cnt++ {
		m.PinNames[cnt] = strlist[cnt]
	}

	/// something try begins
	var pinfo chipset.PinInfo

	pinfo.Name = "inputPin0"
	pinfo.Id = 0
	pinfo.InputPin = true
	pinfo.DataType = reflect.TypeOf((*gocomm.FloatChannel)(nil)).Elem()

	m.Pins["inputPin0"] = pinfo

	pinfo.Name = "inputPin1"
	pinfo.Id = 1
	pinfo.InputPin = true
	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128AChannel)(nil)).Elem()

	m.Pins["inputPin1"] = pinfo

	pinfo.Name = "outputPin0"
	pinfo.Id = 2
	pinfo.InputPin = false
	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128AChannel)(nil)).Elem()

	pinfo.CreateChannel()

	m.Pins["outputPin0"] = pinfo

	pinfo.Name = "outputPin1"
	pinfo.Id = 3
	pinfo.InputPin = false
	pinfo.DataType = reflect.TypeOf((*gocomm.FloatChannel)(nil)).Elem()

	pinfo.CreateChannel()

	m.Pins["outputPin1"] = pinfo

	/// something try ends

}

func (m *ChannelEstimator) InitModules() {

	var totalModules int = 2

	/// AUTO CODE
	/// something try begins
	var minfo chipset.ModuleInfo
	m.Modules = make(map[string]chipset.ModuleInfo, totalModules)
	m.ModuleNames = make(map[int]string, totalModules)

	strlist := [1]string{"estimator"}
	for cnt := 0; cnt < len(strlist); cnt++ {
		m.ModuleNames[cnt] = strlist[cnt]
	}
	var temp, otemp []int

	minfo.Name = "estimator"
	minfo.Id = 0
	minfo.Desc = ""

	temp = append(temp, m.PinByName("inputPin0").Id, m.PinByName("inputPin1").Id)
	otemp = append(otemp, m.PinByName("outputPin0").Id, m.PinByName("outputPin1").Id)

	minfo.InPins = temp
	minfo.OutPins = otemp
	m.Modules["estimator"] = minfo

	/// AUTO CODE
	m.isInitialized = true
}

func (m *ChannelEstimator) Estimator(inputPin0 gocomm.FloatChannel, inputPin1 gocomm.Complex128AChannel) {
	/// Read your data from Input channel(s) [inputPin0]
	/// And write it to OutputChannels  [outputPin0]
	/// For phase of operation

	///a Read t from inputPin0
	///========== if (Ideal mode)
	///b Write t to outputPin1
	///c Read IdealCH from inputPin1
	//========end
	// Else estimates locally and do step d
	///d Write IdealCH to outputPin0

	outputPin0 := chipset.ToComplexACH(m.PinByName("outputPin0"))
	outputPin1 := chipset.ToFloatCH(m.PinByName("outputPin1"))

	count := 1
	var estimatedCHObj gocomm.SComplex128AObj
	for i := 0; i < count; i++ {
		/// Step a
		atTimeObj := <-inputPin0
		count = atTimeObj.MaxExpected

		m.recentTime = atTimeObj.Ch

		// if strings.Contains(atTimeObj.Message, "CE:IDEAL")
		if m.Mode == "IDEAL" {
			/// step b
			outputPin1 <- atTimeObj
			idealChObj := <-inputPin1
			/// Do cross check
			// nothing right now
			fmt.Printf("\n IDEAL Channel %#v", idealChObj)
			///
			m.recentCoeff = idealChObj.Ch
			m.recentTime = idealChObj.TimeStamp
			m.idealTs = idealChObj.Ts
			estimatedCHObj = idealChObj

		} else {

			estimatedCHObj = m.EstimateFn(atTimeObj)
		}

		// Step d
		outputPin0 <- estimatedCHObj

	}

}

func (m *ChannelEstimator) EstimateFn(timeobj gocomm.SFloatObj) (estObj gocomm.SComplex128AObj) {

	m.recentTime = timeobj.TimeStamp
	if m.recentCoeff.Size() == 0 {
		m.recentCoeff = vlib.NewOnesC(1)
	}
	estObj.Ch = m.recentCoeff
	estObj.TimeStamp = timeobj.TimeStamp
	estObj.Ts = timeobj.Ts
	estObj.MaxExpected = timeobj.MaxExpected
	estObj.Message = timeobj.Message + " CE:UNKNOWN"
	return estObj
}

// else {
// 		var idealChObj gocomm.SComplex128AObj
// 		if m.recentCoeff.Size() == 0 {
// 			m.recentCoeff = vlib.NewOnesC(1)
// 		}
// 		idealChObj.Ch = m.recentCoeff
// 		idealChObj.TimeStamp = atTimeObj.TimeStamp
// 		idealChObj.Ts = atTimeObj.Ts
// 		idealChObj.MaxExpected = atTimeObj.MaxExpected
// 		idealChObj.Message = atTimeObj.MaxExpected + " CE:UNKNOWN"
// 		outputPin0 <- idealChObj
// 		m.recentTime = atTimeObj.TimeStamp
// 	}
