package custom

import (
	"fmt"
	"reflect"
	"github.com/wiless/gocomm"
	"github.com/wiless/gocomm/chipset"
	"github.com/wiless/gocomm/sources"
)

type SampleChip struct {
	name          string
	isInitialized bool
	Pins          map[string]chipset.PinInfo
	Modules       map[string]chipset.ModuleInfo
	ModuleNames   map[int]string
	PinNames      map[int]string
}

/// AutoGenerated through script

func (m SampleChip) InPinCount() int {
	return 2
}

func (m SampleChip) OutPinCount() int {
	return 2
}

func (m SampleChip) Pin(pid int) chipset.PinInfo {
	return m.Pins[m.PinNames[pid]]
}

func (m SampleChip) PinIn(pid int) chipset.PinInfo {
	if pid >= m.InPinCount() {
		fmt.Printf("%d > No of Input Pins %d", pid, m.InPinCount())
		var result chipset.PinInfo
		result.Id = -1
		return result
	}

	return m.Pins[m.PinNames[pid]]

}
func (m SampleChip) PinByID(pid int) chipset.PinInfo {

	return m.Pins[m.PinNames[pid]]
}

func (m SampleChip) PinOut(pid int) chipset.PinInfo {
	if pid >= m.OutPinCount() {
		fmt.Printf("%d > No of Output Pins %d", pid, m.OutPinCount())
		var result chipset.PinInfo
		result.Id = -1
		return result
	}
	return m.Pins[m.PinNames[pid+m.InPinCount()]]

}

func (m SampleChip) PinByName(pinname string) chipset.PinInfo {
	return m.Pins[pinname]
}

func (m SampleChip) ModulesCount() int {
	return 2
}
func (m SampleChip) ModuleByName(mname string) chipset.ModuleInfo {
	return m.Modules[mname]
}

func (m SampleChip) Module(moduleid int) chipset.ModuleInfo {
	return m.ModuleByName(m.ModuleNames[moduleid])
}

func (m SampleChip) SayHello() {
	fmt.Printf("\n Hi from \n %v", m.Name())
}

func (m SampleChip) Name() string {
	return "SampleChip"
}

func (m SampleChip) IsInitialized() bool {
	return m.isInitialized
}

func (m *SampleChip) InitializeChip() {
	m.InitPins()
	m.InitModules()
}

func (m *SampleChip) InitModules() {

}

func (m *SampleChip) InitPins() {
	totalpins := m.InPinCount() + m.OutPinCount()
	m.Pins = make(map[string]chipset.PinInfo, totalpins)
	m.PinNames = make(map[int]string, totalpins)
	strlist := [4]string{"bitIn", "symbolIn", "symbolOut", "bitOut"}

	testCmplxCH := gocomm.NewComplex128Channel()
	testBitch := gocomm.NewBitChannel()
	testBitch := gocomm.NewBitChannel()

	/// something try begins
	var pinfo chipset.PinInfo

	pinfo.Name = "bitIn"
	pinfo.Id = 0
	pinfo.InputPin = true
	pinfo.DataType = reflect.TypeOf((*gocomm.BitChannel)(nil)).Elem()

	m.Pins["bitIn"] = pinfo

	pinfo.Name = "symbolIn"
	pinfo.Id = 1
	pinfo.InputPin = true
	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128Channel)(nil)).Elem()

	m.Pins["symbolIn"] = pinfo

	pinfo.Name = "symbolOut"
	pinfo.Id = 2
	pinfo.InputPin = false
	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128Channel)(nil)).Elem()

	pinfo.CreateChannel()

	m.Pins["symbolOut"] = pinfo

	pinfo.Name = "bitOut"
	pinfo.Id = 3
	pinfo.InputPin = false
	pinfo.DataType = reflect.TypeOf((*gocomm.Complex128Channel)(nil)).Elem()

	pinfo.CreateChannel()

	m.Pins["bitOut"] = pinfo

	/// something try ends

	for i := 0; i < totalpins; i++ {
		m.PinNames[i] = strlist[i]
	}

	for i := 0; i < totalpins; i++ {
		var pinfo chipset.PinInfo
		pinfo.Name = j.Pins[i]
		m.Pins[m.PinNames[i]] = pinfo

	}

}
